<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pytia_property_manager.app.widgets.processes API documentation</title>
<meta name="description" content="Widget set for processes. Creates the processes in the process frame and provides
variables for all child widgets …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pytia_property_manager.app.widgets.processes</code></h1>
</header>
<section id="section-intro">
<p>Widget set for processes. Creates the processes in the process frame and provides
variables for all child widgets.</p>
<p>This submodule has two classes:</p>
<ul>
<li>ProcessWidget: Holds all widgets related to one process. Currently a label, a combobox and
a note text widget.</li>
<li>ProcessWidgets: Manages multiple instances of ProcessWidget. Has managing methods like add
or delete.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Widget set for processes. Creates the processes in the process frame and provides
    variables for all child widgets.

    This submodule has two classes:

    - ProcessWidget: Holds all widgets related to one process. Currently a label, a combobox and \
        a note text widget.
    - ProcessWidgets: Manages multiple instances of ProcessWidget. Has managing methods like add \
        or delete.
&#34;&#34;&#34;

import tkinter as tk
from tkinter import StringVar
from tkinter import messagebox as tkmsg
from typing import Callable
from typing import Dict
from typing import List
from typing import Literal
from typing import Optional

from pytia.log import log
from pytia_ui_tools.widgets.texts import ScrolledText
from resources import resource
from ttkbootstrap import Combobox
from ttkbootstrap import Frame
from ttkbootstrap import Label
from ttkbootstrap import Labelframe


class ProcessWidget:
    &#34;&#34;&#34;The process widget class. Holds all widgets related to one process.&#34;&#34;&#34;

    MARGIN_X = 10
    MARGIN_Y = 10

    def __init__(
        self,
        root: Frame | Labelframe,
        pid: int,
        callback_combo: Callable,
        callback_process: Callable,
    ) -&gt; None:
        &#34;&#34;&#34;
        Inits the ProcessWidget class. Holds all widgets for one process (label, combobox and note).

        Args:
            root (tk.Tk | tk.Frame | ttk.Frame | ttk.Labelframe): The parent of all widgets (the \
                tkinter parent frame).
            pid (int): The id of this instance.
            callback_combo (Callable): The callback method for combobox selections.
            callback_process (Callable): The callback for the process variable trace.
        &#34;&#34;&#34;
        self._root = root
        self._pid = pid
        self._func_combo = callback_combo
        self._func_process = callback_process

        self._process_var = StringVar()
        self._process_var.trace_add(&#34;write&#34;, self._callback_process_var)
        self._note_var = StringVar()

        self._state = tk.NORMAL
        self._bottom_space = False

        self.lbl_process = Label(
            self._root,
            text=f&#34;Process {self._pid}&#34;,
            width=15,
        )
        self.lbl_process.grid(
            row=(self._pid - resource.settings.processes.first) * 2,
            column=0,
            padx=(ProcessWidget.MARGIN_X, 5),
            pady=(
                ProcessWidget.MARGIN_Y
                if self._pid == resource.settings.processes.first
                else 2,
                2,
            ),
            sticky=&#34;nsew&#34;,
        )

        combo_process_values = [&#34;&#34;]
        combo_process_values.extend([p.name for p in resource.processes])
        self.combo_process = Combobox(
            self._root,
            values=combo_process_values,
            textvariable=self._process_var,
            state=&#34;readonly&#34;,
        )
        self.combo_process.grid(
            row=(self._pid - resource.settings.processes.first) * 2,
            column=1,
            padx=(5, ProcessWidget.MARGIN_X),
            pady=(
                ProcessWidget.MARGIN_Y + 1
                if self._pid == resource.settings.processes.first
                else 2,
                2,
            ),
            sticky=&#34;new&#34;,
        )
        self.combo_process.bind(&#34;&lt;&lt;ComboboxSelected&gt;&gt;&#34;, self._callback_combo)

        self.text_note_process = ScrolledText(
            parent=self._root,
            textvariable=self._note_var,
            height=4,
            width=30,
            state=tk.DISABLED,
            wrap=tk.WORD,
        )
        self.text_note_process.grid(
            row=(self._pid - resource.settings.processes.first) * 2 + 1,
            column=1,
            padx=(3, ProcessWidget.MARGIN_X - 1),
            pady=2,
            sticky=&#34;nsew&#34;,
        )

        self._root.grid_rowconfigure(
            (self._pid - resource.settings.processes.first) * 2 + 1, weight=1
        )

    @property
    def parent(self) -&gt; Frame | Labelframe:
        &#34;&#34;&#34;Returns the parent of this instance.&#34;&#34;&#34;
        return self._root

    @property
    def pid(self) -&gt; int:
        &#34;&#34;&#34;Returns the process id of this instance.&#34;&#34;&#34;
        return self._pid

    @property
    def process_var(self) -&gt; StringVar:
        &#34;&#34;&#34;Returns the variable of the combobox selection.&#34;&#34;&#34;
        return self._process_var

    @process_var.setter
    def process_var(self, value: str) -&gt; None:
        &#34;&#34;&#34;Sets the value of the combobox variable.&#34;&#34;&#34;
        self._process_var.set(value)

    @property
    def note_var(self) -&gt; StringVar:
        &#34;&#34;&#34;Returns the variable of the note widget.&#34;&#34;&#34;
        return self._note_var

    @note_var.setter
    def note_var(self, value: str) -&gt; None:
        &#34;&#34;&#34;Sets the value of the note widgets variable.&#34;&#34;&#34;
        self._note_var.set(value)

    @property
    def state(self) -&gt; str:
        &#34;&#34;&#34;Returns the state of the widgets. Combobox and note are combined.&#34;&#34;&#34;
        return self._state

    @state.setter
    def state(self, value: Literal[&#34;normal&#34;, &#34;disabled&#34;]) -&gt; None:
        &#34;&#34;&#34;
        Sets the state of the widgets. Combobox and note are combined.
        The state of the note widget only `NORMAL`if the state of the combobox is not `DISABLED`
        and the StringVar value of the process is not empty.
        &#34;&#34;&#34;
        self.combo_process.configure(
            state=&#34;readonly&#34; if value == tk.NORMAL else tk.DISABLED
        )
        self.text_note_process.state = (
            tk.NORMAL if self._process_var.get() and value == tk.NORMAL else tk.DISABLED
        )
        self._state = value

    @property
    def bottom_space(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns the current bottom space state of the widget. The last widget needs a higher margin
        value on the bottom, all other widgets not. This is for a nice look.
        &#34;&#34;&#34;
        return self._bottom_space

    @bottom_space.setter
    def bottom_space(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Switches the bottom space value.&#34;&#34;&#34;
        self.text_note_process.grid_configure(
            pady=(2, ProcessWidget.MARGIN_Y if value else 2)
        )
        self._bottom_space = value

    def _callback_combo(self, event: tk.Event) -&gt; None:
        &#34;&#34;&#34;
        The combobox-selection callback.
        Calls the `_callback_combo` method of the `ProcessWidgets` class.
        &#34;&#34;&#34;
        self._func_combo(self._pid, event.widget.get())

    def _callback_process_var(self, *_) -&gt; None:
        &#34;&#34;&#34;
        The process variable trace callback.
        Calls the `_callback_process` method of the `ProcessWidgets` class.
        &#34;&#34;&#34;
        self._func_process(self._pid, self._process_var.get())


class ProcessWidgets:
    &#34;&#34;&#34;The process widgets class. Holds all process widgets.&#34;&#34;&#34;

    def __init__(
        self,
        root: Frame | Labelframe,
        material_metadata: StringVar,
    ) -&gt; None:
        &#34;&#34;&#34;
        Inits the ProcessWidgets class. This class handles the ProcessWidget instances.

        Args:
            root (tk.Tk | tk.Frame | ttk.Frame | ttk.Labelframe): The parent of the widgets.
            material_meta (StringVar): The metadata from a selected material.
        &#34;&#34;&#34;
        self._root = root
        self._material_meta = material_metadata
        self._init_amount = int(resource.settings.processes.min)
        self._process_widgets: Dict[int, ProcessWidget] = {}
        self._current_pid = resource.settings.processes.first - 1

        self._root.grid_columnconfigure(1, weight=1)

        # On instantiation the minimum amount of widgets is created.
        for _ in range(self._init_amount):
            self.add()
        self.state(tk.DISABLED)

    @property
    def process_vars(self) -&gt; List[StringVar]:
        &#34;&#34;&#34;Returns a list of all StringVar variables of the process combobox-selections.&#34;&#34;&#34;
        return [p.process_var for p in self._process_widgets.values()]

    @property
    def note_vars(self) -&gt; List[StringVar]:
        &#34;&#34;&#34;Returns a list of all StringVar variables for the process notes.&#34;&#34;&#34;
        return [p.note_var for p in self._process_widgets.values()]

    def add(
        self, process_value: Optional[str] = None, note_value: Optional[str] = None
    ) -&gt; Optional[ProcessWidget]:
        &#34;&#34;&#34;Adds the process combobox and the process note widgets.&#34;&#34;&#34;
        new_pid = self._current_pid + 1
        if len(self._process_widgets) &lt;= resource.settings.processes.max - 1:
            widget = ProcessWidget(
                root=self._root,
                pid=new_pid,
                callback_combo=self._callback_combo,
                callback_process=self._callback_process,
            )
            widget.bottom_space = True
            if new_pid &gt; resource.settings.processes.first:
                prev = self.get(pid=new_pid - 1)
                prev.bottom_space = False
                # Only allow the selection of the process if the previous
                # process has been selected. This way we don&#39;t have to sort
                # processes later, because there are no &#39;blank&#39; processes.
                if prev.process_var.get():
                    widget.state = tk.NORMAL
                else:
                    widget.state = tk.DISABLED

            # self._process_widgets.append(w)
            self._process_widgets[new_pid] = widget
            self._current_pid = new_pid

            if process_value:
                widget.process_var.set(process_value)
            if process_value and note_value:
                widget.note_var.set(note_value)

            log.debug(f&#34;Added new process {new_pid}&#34;)
            return widget
        return None

    def clear(self, pid: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Clears the content of the widgets with the given pid (process id).
        Clears all processes if no pid is provided.

        Args:
        pid (Optional[int], optional): The process id, which widgets have \
            to be cleared. Defaults to None.
        &#34;&#34;&#34;
        if pid:
            process = self.get(pid)
            process.process_var.set(&#34;&#34;)
            process.note_var.set(&#34;&#34;)
        else:
            for widget in self._process_widgets.values():
                widget.process_var.set(&#34;&#34;)
                widget.note_var.set(&#34;&#34;)

    def remove(self, pid: int) -&gt; None:
        &#34;&#34;&#34;
        Removes the process combobox and the process note from the frame.
        All widgets (all processes) are going to be deleted, and re-added,
        except the one with the given pid (process-id). This ensures that
        the tkinter grid will always work.

        Args:
            pid (int): The id of the process which will be deleted.
        &#34;&#34;&#34;
        process_store: List[str] = []
        note_store: List[str] = []

        # First: Destroy all widgets from the all processes.
        # Store all processes temporarily.
        for i, widget in enumerate(self._process_widgets.values()):
            process_store.append(widget.process_var.get())
            note_store.append(widget.note_var.get())

            widget.lbl_process.grid_forget()
            widget.combo_process.grid_forget()
            widget.text_note_process.grid_forget()

            widget.lbl_process.destroy()
            widget.combo_process.destroy()
            widget.text_note_process.destroy()
            widget.parent.grid_rowconfigure(i * 2 + 1, weight=0)

        # Remove the process which shall be removed from
        # the list from the temporary store.
        process_store.pop(pid - resource.settings.processes.first)
        note_store.pop(pid - resource.settings.processes.first)

        # Clear the process list that holds all widgets.
        self._process_widgets.clear()

        # Reset the pid counter
        self._current_pid = resource.settings.processes.first - 1

        # Add all widgets from the process store.
        # Remember: The process from the given pid isn&#39;t in the temp
        # store anymore.
        for i, _ in enumerate(process_store):
            self.add(process_value=process_store[i], note_value=note_store[i])

        # Add all processes from the init_amount, if the amount
        # of remaining processes is less than the init amount.
        for i in range(len(process_store), self._init_amount):
            self.add()

        # Add another widget set, if the current one has a value.
        if process_store[-1]:
            self.add()

        log.debug(f&#34;Removed process {pid}&#34;)

    def get(self, pid: int) -&gt; ProcessWidget:
        &#34;&#34;&#34;
        Returns a process widget by its pid.

        Args:
            pid (int): The pid of the desired ProcessWidget.

        Returns:
            ProcessWidget: The desired ProcessWidget.
        &#34;&#34;&#34;
        return self._process_widgets[pid]

    def exists(self, pid: int) -&gt; bool:
        &#34;&#34;&#34;
        Returns wether a pid exists or not.

        Args:
            pid (int): The pid to look for.

        Returns:
            bool: True, if the process exists, False otherwise.
        &#34;&#34;&#34;
        # return True if len(self._process_widgets) &gt; pid else False
        return bool(pid in self._process_widgets)

    def state(
        self, state: Literal[&#34;normal&#34;, &#34;disabled&#34;], pid: Optional[int] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the state of process widgets. A process widget is only set to state `NORMAL` if the
        previous widget has a value. The state of the process note widgets is set via the
        trace callback of the process widgets StringVar, see method `_callback_process`.

        Args:
            state (Literal[&amp;quot;normal&amp;quot;, &amp;quot;disabled&amp;quot;]): The tkinter-state.
            pid (Optional[int], optional): The pid from which to set the process. \
                If None, all processes will be set to the given state. Defaults to None.
        &#34;&#34;&#34;
        if pid:
            self.get(pid).state = state
        else:
            for _, widget in enumerate(self._process_widgets.values()):
                if (
                    state == tk.DISABLED
                    or widget.pid == resource.settings.processes.first
                    or (
                        widget.pid &gt; resource.settings.processes.first
                        and self._process_widgets[widget.pid - 1].process_var.get()
                    )
                ):
                    widget.state = state

    def _callback_combo(self, pid: int, value: str) -&gt; None:
        &#34;&#34;&#34;
        Callback for the process combobox.

         - Removes the widget if the value is None.
         - Adds a following widget if the value is set and no following widget exists yet.
         - Clears the note text widget if the callback value is empty.
         - Adds the process note to the note widget.

        Args:
            pid (int): The pid from which the callback is triggered.
            value (str): The value of the combobox.
        &#34;&#34;&#34;
        log.debug(f&#34;Callback combobox process: pid={pid}, value={value}&#34;)
        process = self._process_widgets[pid]

        if value:
            c = len(self._process_widgets) + resource.settings.processes.first

            # Set the state of the following widget to NORMAL
            if pid + 1 &lt; c:
                self.get(pid + 1).state = tk.NORMAL

            # Adds another widget set
            if pid == c - 1:
                self.add()

            # Ask the user if the note value shall be replaced
            if process.note_var.get():
                use_preset_note = tkmsg.askyesno(
                    title=resource.settings.title,
                    message=(
                        f&#34;There is already a note set for process {pid}.\n\n&#34;
                        &#34;Do you want to replace the current note with a preset?&#34;
                    ),
                )
            else:
                use_preset_note = True

            # Write the preset note value
            if use_preset_note:
                note_value = resource.get_process_note(value)
                meta_value = self._material_meta.get()

                resource_process = resource.get_process_by_name(
                    process.process_var.get()
                )
                metadata_required = (
                    True
                    if resource_process and resource_process.metadata_required
                    else False
                )

                if &#34;$&#34; in note_value and meta_value:
                    note_value = note_value.replace(&#34;$&#34;, meta_value)
                elif &#34;$&#34; in note_value and metadata_required and not meta_value:
                    tkmsg.showwarning(
                        message=(
                            f&#34;The process {process.process_var.get()} requires metadata.\n\n&#34;
                            &#34;Please select the correct metadata with the material manager. &#34;
                            &#34;To do so, click the &#39;select&#39; button besides the material input field.&#34;
                        )
                    )
                else:
                    note_value = note_value.replace(&#34;$&#34;, &#34;-&#34;)
                process.note_var.set(note_value)
        else:
            # Remove the widget set if the process has no value
            self.remove(pid)

    def _callback_process(self, pid: int, value: str) -&gt; None:
        &#34;&#34;&#34;
        Callback for the process StringVar trace.

         - Sets the note widget as disabled or normal depending of the value.
         - Sets the state of the following process widgets dependent of the value.

        Args:
            pid (int): The pid from which the trace callback is triggered.
            value (str): The value of the variable.
        &#34;&#34;&#34;
        log.debug(f&#34;Callback trace process: pid={pid}, value={value}&#34;)

        process = self._process_widgets[pid]

        if bool(value):
            process.text_note_process.state = tk.NORMAL
        else:
            process.note_var.set(&#34;&#34;)
            process.text_note_process.state = tk.DISABLED

        if self.exists(pid=pid + 1):
            self.get(pid + 1).state = tk.NORMAL</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget"><code class="flex name class">
<span>class <span class="ident">ProcessWidget</span></span>
<span>(</span><span>root: tkinter.ttk.Frame | tkinter.ttk.Labelframe, pid: int, callback_combo: Callable, callback_process: Callable)</span>
</code></dt>
<dd>
<div class="desc"><p>The process widget class. Holds all widgets related to one process.</p>
<p>Inits the ProcessWidget class. Holds all widgets for one process (label, combobox and note).</p>
<h2 id="args">Args</h2>
<dl>
<dt>root (tk.Tk | tk.Frame | ttk.Frame | ttk.Labelframe): The parent of all widgets (the
tkinter parent frame).</dt>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of this instance.</dd>
<dt><strong><code>callback_combo</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The callback method for combobox selections.</dd>
<dt><strong><code>callback_process</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The callback for the process variable trace.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessWidget:
    &#34;&#34;&#34;The process widget class. Holds all widgets related to one process.&#34;&#34;&#34;

    MARGIN_X = 10
    MARGIN_Y = 10

    def __init__(
        self,
        root: Frame | Labelframe,
        pid: int,
        callback_combo: Callable,
        callback_process: Callable,
    ) -&gt; None:
        &#34;&#34;&#34;
        Inits the ProcessWidget class. Holds all widgets for one process (label, combobox and note).

        Args:
            root (tk.Tk | tk.Frame | ttk.Frame | ttk.Labelframe): The parent of all widgets (the \
                tkinter parent frame).
            pid (int): The id of this instance.
            callback_combo (Callable): The callback method for combobox selections.
            callback_process (Callable): The callback for the process variable trace.
        &#34;&#34;&#34;
        self._root = root
        self._pid = pid
        self._func_combo = callback_combo
        self._func_process = callback_process

        self._process_var = StringVar()
        self._process_var.trace_add(&#34;write&#34;, self._callback_process_var)
        self._note_var = StringVar()

        self._state = tk.NORMAL
        self._bottom_space = False

        self.lbl_process = Label(
            self._root,
            text=f&#34;Process {self._pid}&#34;,
            width=15,
        )
        self.lbl_process.grid(
            row=(self._pid - resource.settings.processes.first) * 2,
            column=0,
            padx=(ProcessWidget.MARGIN_X, 5),
            pady=(
                ProcessWidget.MARGIN_Y
                if self._pid == resource.settings.processes.first
                else 2,
                2,
            ),
            sticky=&#34;nsew&#34;,
        )

        combo_process_values = [&#34;&#34;]
        combo_process_values.extend([p.name for p in resource.processes])
        self.combo_process = Combobox(
            self._root,
            values=combo_process_values,
            textvariable=self._process_var,
            state=&#34;readonly&#34;,
        )
        self.combo_process.grid(
            row=(self._pid - resource.settings.processes.first) * 2,
            column=1,
            padx=(5, ProcessWidget.MARGIN_X),
            pady=(
                ProcessWidget.MARGIN_Y + 1
                if self._pid == resource.settings.processes.first
                else 2,
                2,
            ),
            sticky=&#34;new&#34;,
        )
        self.combo_process.bind(&#34;&lt;&lt;ComboboxSelected&gt;&gt;&#34;, self._callback_combo)

        self.text_note_process = ScrolledText(
            parent=self._root,
            textvariable=self._note_var,
            height=4,
            width=30,
            state=tk.DISABLED,
            wrap=tk.WORD,
        )
        self.text_note_process.grid(
            row=(self._pid - resource.settings.processes.first) * 2 + 1,
            column=1,
            padx=(3, ProcessWidget.MARGIN_X - 1),
            pady=2,
            sticky=&#34;nsew&#34;,
        )

        self._root.grid_rowconfigure(
            (self._pid - resource.settings.processes.first) * 2 + 1, weight=1
        )

    @property
    def parent(self) -&gt; Frame | Labelframe:
        &#34;&#34;&#34;Returns the parent of this instance.&#34;&#34;&#34;
        return self._root

    @property
    def pid(self) -&gt; int:
        &#34;&#34;&#34;Returns the process id of this instance.&#34;&#34;&#34;
        return self._pid

    @property
    def process_var(self) -&gt; StringVar:
        &#34;&#34;&#34;Returns the variable of the combobox selection.&#34;&#34;&#34;
        return self._process_var

    @process_var.setter
    def process_var(self, value: str) -&gt; None:
        &#34;&#34;&#34;Sets the value of the combobox variable.&#34;&#34;&#34;
        self._process_var.set(value)

    @property
    def note_var(self) -&gt; StringVar:
        &#34;&#34;&#34;Returns the variable of the note widget.&#34;&#34;&#34;
        return self._note_var

    @note_var.setter
    def note_var(self, value: str) -&gt; None:
        &#34;&#34;&#34;Sets the value of the note widgets variable.&#34;&#34;&#34;
        self._note_var.set(value)

    @property
    def state(self) -&gt; str:
        &#34;&#34;&#34;Returns the state of the widgets. Combobox and note are combined.&#34;&#34;&#34;
        return self._state

    @state.setter
    def state(self, value: Literal[&#34;normal&#34;, &#34;disabled&#34;]) -&gt; None:
        &#34;&#34;&#34;
        Sets the state of the widgets. Combobox and note are combined.
        The state of the note widget only `NORMAL`if the state of the combobox is not `DISABLED`
        and the StringVar value of the process is not empty.
        &#34;&#34;&#34;
        self.combo_process.configure(
            state=&#34;readonly&#34; if value == tk.NORMAL else tk.DISABLED
        )
        self.text_note_process.state = (
            tk.NORMAL if self._process_var.get() and value == tk.NORMAL else tk.DISABLED
        )
        self._state = value

    @property
    def bottom_space(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns the current bottom space state of the widget. The last widget needs a higher margin
        value on the bottom, all other widgets not. This is for a nice look.
        &#34;&#34;&#34;
        return self._bottom_space

    @bottom_space.setter
    def bottom_space(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Switches the bottom space value.&#34;&#34;&#34;
        self.text_note_process.grid_configure(
            pady=(2, ProcessWidget.MARGIN_Y if value else 2)
        )
        self._bottom_space = value

    def _callback_combo(self, event: tk.Event) -&gt; None:
        &#34;&#34;&#34;
        The combobox-selection callback.
        Calls the `_callback_combo` method of the `ProcessWidgets` class.
        &#34;&#34;&#34;
        self._func_combo(self._pid, event.widget.get())

    def _callback_process_var(self, *_) -&gt; None:
        &#34;&#34;&#34;
        The process variable trace callback.
        Calls the `_callback_process` method of the `ProcessWidgets` class.
        &#34;&#34;&#34;
        self._func_process(self._pid, self._process_var.get())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.MARGIN_X"><code class="name">var <span class="ident">MARGIN_X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.MARGIN_Y"><code class="name">var <span class="ident">MARGIN_Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.bottom_space"><code class="name">var <span class="ident">bottom_space</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns the current bottom space state of the widget. The last widget needs a higher margin
value on the bottom, all other widgets not. This is for a nice look.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bottom_space(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns the current bottom space state of the widget. The last widget needs a higher margin
    value on the bottom, all other widgets not. This is for a nice look.
    &#34;&#34;&#34;
    return self._bottom_space</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.note_var"><code class="name">var <span class="ident">note_var</span> : tkinter.StringVar</code></dt>
<dd>
<div class="desc"><p>Returns the variable of the note widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def note_var(self) -&gt; StringVar:
    &#34;&#34;&#34;Returns the variable of the note widget.&#34;&#34;&#34;
    return self._note_var</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.parent"><code class="name">var <span class="ident">parent</span> : tkinter.ttk.Frame | tkinter.ttk.Labelframe</code></dt>
<dd>
<div class="desc"><p>Returns the parent of this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self) -&gt; Frame | Labelframe:
    &#34;&#34;&#34;Returns the parent of this instance.&#34;&#34;&#34;
    return self._root</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.pid"><code class="name">var <span class="ident">pid</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the process id of this instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pid(self) -&gt; int:
    &#34;&#34;&#34;Returns the process id of this instance.&#34;&#34;&#34;
    return self._pid</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.process_var"><code class="name">var <span class="ident">process_var</span> : tkinter.StringVar</code></dt>
<dd>
<div class="desc"><p>Returns the variable of the combobox selection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def process_var(self) -&gt; StringVar:
    &#34;&#34;&#34;Returns the variable of the combobox selection.&#34;&#34;&#34;
    return self._process_var</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidget.state"><code class="name">var <span class="ident">state</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the state of the widgets. Combobox and note are combined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; str:
    &#34;&#34;&#34;Returns the state of the widgets. Combobox and note are combined.&#34;&#34;&#34;
    return self._state</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets"><code class="flex name class">
<span>class <span class="ident">ProcessWidgets</span></span>
<span>(</span><span>root: tkinter.ttk.Frame | tkinter.ttk.Labelframe, material_metadata: tkinter.StringVar)</span>
</code></dt>
<dd>
<div class="desc"><p>The process widgets class. Holds all process widgets.</p>
<p>Inits the ProcessWidgets class. This class handles the ProcessWidget instances.</p>
<h2 id="args">Args</h2>
<dl>
<dt>root (tk.Tk | tk.Frame | ttk.Frame | ttk.Labelframe): The parent of the widgets.</dt>
<dt><strong><code>material_meta</code></strong> :&ensp;<code>StringVar</code></dt>
<dd>The metadata from a selected material.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessWidgets:
    &#34;&#34;&#34;The process widgets class. Holds all process widgets.&#34;&#34;&#34;

    def __init__(
        self,
        root: Frame | Labelframe,
        material_metadata: StringVar,
    ) -&gt; None:
        &#34;&#34;&#34;
        Inits the ProcessWidgets class. This class handles the ProcessWidget instances.

        Args:
            root (tk.Tk | tk.Frame | ttk.Frame | ttk.Labelframe): The parent of the widgets.
            material_meta (StringVar): The metadata from a selected material.
        &#34;&#34;&#34;
        self._root = root
        self._material_meta = material_metadata
        self._init_amount = int(resource.settings.processes.min)
        self._process_widgets: Dict[int, ProcessWidget] = {}
        self._current_pid = resource.settings.processes.first - 1

        self._root.grid_columnconfigure(1, weight=1)

        # On instantiation the minimum amount of widgets is created.
        for _ in range(self._init_amount):
            self.add()
        self.state(tk.DISABLED)

    @property
    def process_vars(self) -&gt; List[StringVar]:
        &#34;&#34;&#34;Returns a list of all StringVar variables of the process combobox-selections.&#34;&#34;&#34;
        return [p.process_var for p in self._process_widgets.values()]

    @property
    def note_vars(self) -&gt; List[StringVar]:
        &#34;&#34;&#34;Returns a list of all StringVar variables for the process notes.&#34;&#34;&#34;
        return [p.note_var for p in self._process_widgets.values()]

    def add(
        self, process_value: Optional[str] = None, note_value: Optional[str] = None
    ) -&gt; Optional[ProcessWidget]:
        &#34;&#34;&#34;Adds the process combobox and the process note widgets.&#34;&#34;&#34;
        new_pid = self._current_pid + 1
        if len(self._process_widgets) &lt;= resource.settings.processes.max - 1:
            widget = ProcessWidget(
                root=self._root,
                pid=new_pid,
                callback_combo=self._callback_combo,
                callback_process=self._callback_process,
            )
            widget.bottom_space = True
            if new_pid &gt; resource.settings.processes.first:
                prev = self.get(pid=new_pid - 1)
                prev.bottom_space = False
                # Only allow the selection of the process if the previous
                # process has been selected. This way we don&#39;t have to sort
                # processes later, because there are no &#39;blank&#39; processes.
                if prev.process_var.get():
                    widget.state = tk.NORMAL
                else:
                    widget.state = tk.DISABLED

            # self._process_widgets.append(w)
            self._process_widgets[new_pid] = widget
            self._current_pid = new_pid

            if process_value:
                widget.process_var.set(process_value)
            if process_value and note_value:
                widget.note_var.set(note_value)

            log.debug(f&#34;Added new process {new_pid}&#34;)
            return widget
        return None

    def clear(self, pid: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Clears the content of the widgets with the given pid (process id).
        Clears all processes if no pid is provided.

        Args:
        pid (Optional[int], optional): The process id, which widgets have \
            to be cleared. Defaults to None.
        &#34;&#34;&#34;
        if pid:
            process = self.get(pid)
            process.process_var.set(&#34;&#34;)
            process.note_var.set(&#34;&#34;)
        else:
            for widget in self._process_widgets.values():
                widget.process_var.set(&#34;&#34;)
                widget.note_var.set(&#34;&#34;)

    def remove(self, pid: int) -&gt; None:
        &#34;&#34;&#34;
        Removes the process combobox and the process note from the frame.
        All widgets (all processes) are going to be deleted, and re-added,
        except the one with the given pid (process-id). This ensures that
        the tkinter grid will always work.

        Args:
            pid (int): The id of the process which will be deleted.
        &#34;&#34;&#34;
        process_store: List[str] = []
        note_store: List[str] = []

        # First: Destroy all widgets from the all processes.
        # Store all processes temporarily.
        for i, widget in enumerate(self._process_widgets.values()):
            process_store.append(widget.process_var.get())
            note_store.append(widget.note_var.get())

            widget.lbl_process.grid_forget()
            widget.combo_process.grid_forget()
            widget.text_note_process.grid_forget()

            widget.lbl_process.destroy()
            widget.combo_process.destroy()
            widget.text_note_process.destroy()
            widget.parent.grid_rowconfigure(i * 2 + 1, weight=0)

        # Remove the process which shall be removed from
        # the list from the temporary store.
        process_store.pop(pid - resource.settings.processes.first)
        note_store.pop(pid - resource.settings.processes.first)

        # Clear the process list that holds all widgets.
        self._process_widgets.clear()

        # Reset the pid counter
        self._current_pid = resource.settings.processes.first - 1

        # Add all widgets from the process store.
        # Remember: The process from the given pid isn&#39;t in the temp
        # store anymore.
        for i, _ in enumerate(process_store):
            self.add(process_value=process_store[i], note_value=note_store[i])

        # Add all processes from the init_amount, if the amount
        # of remaining processes is less than the init amount.
        for i in range(len(process_store), self._init_amount):
            self.add()

        # Add another widget set, if the current one has a value.
        if process_store[-1]:
            self.add()

        log.debug(f&#34;Removed process {pid}&#34;)

    def get(self, pid: int) -&gt; ProcessWidget:
        &#34;&#34;&#34;
        Returns a process widget by its pid.

        Args:
            pid (int): The pid of the desired ProcessWidget.

        Returns:
            ProcessWidget: The desired ProcessWidget.
        &#34;&#34;&#34;
        return self._process_widgets[pid]

    def exists(self, pid: int) -&gt; bool:
        &#34;&#34;&#34;
        Returns wether a pid exists or not.

        Args:
            pid (int): The pid to look for.

        Returns:
            bool: True, if the process exists, False otherwise.
        &#34;&#34;&#34;
        # return True if len(self._process_widgets) &gt; pid else False
        return bool(pid in self._process_widgets)

    def state(
        self, state: Literal[&#34;normal&#34;, &#34;disabled&#34;], pid: Optional[int] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the state of process widgets. A process widget is only set to state `NORMAL` if the
        previous widget has a value. The state of the process note widgets is set via the
        trace callback of the process widgets StringVar, see method `_callback_process`.

        Args:
            state (Literal[&amp;quot;normal&amp;quot;, &amp;quot;disabled&amp;quot;]): The tkinter-state.
            pid (Optional[int], optional): The pid from which to set the process. \
                If None, all processes will be set to the given state. Defaults to None.
        &#34;&#34;&#34;
        if pid:
            self.get(pid).state = state
        else:
            for _, widget in enumerate(self._process_widgets.values()):
                if (
                    state == tk.DISABLED
                    or widget.pid == resource.settings.processes.first
                    or (
                        widget.pid &gt; resource.settings.processes.first
                        and self._process_widgets[widget.pid - 1].process_var.get()
                    )
                ):
                    widget.state = state

    def _callback_combo(self, pid: int, value: str) -&gt; None:
        &#34;&#34;&#34;
        Callback for the process combobox.

         - Removes the widget if the value is None.
         - Adds a following widget if the value is set and no following widget exists yet.
         - Clears the note text widget if the callback value is empty.
         - Adds the process note to the note widget.

        Args:
            pid (int): The pid from which the callback is triggered.
            value (str): The value of the combobox.
        &#34;&#34;&#34;
        log.debug(f&#34;Callback combobox process: pid={pid}, value={value}&#34;)
        process = self._process_widgets[pid]

        if value:
            c = len(self._process_widgets) + resource.settings.processes.first

            # Set the state of the following widget to NORMAL
            if pid + 1 &lt; c:
                self.get(pid + 1).state = tk.NORMAL

            # Adds another widget set
            if pid == c - 1:
                self.add()

            # Ask the user if the note value shall be replaced
            if process.note_var.get():
                use_preset_note = tkmsg.askyesno(
                    title=resource.settings.title,
                    message=(
                        f&#34;There is already a note set for process {pid}.\n\n&#34;
                        &#34;Do you want to replace the current note with a preset?&#34;
                    ),
                )
            else:
                use_preset_note = True

            # Write the preset note value
            if use_preset_note:
                note_value = resource.get_process_note(value)
                meta_value = self._material_meta.get()

                resource_process = resource.get_process_by_name(
                    process.process_var.get()
                )
                metadata_required = (
                    True
                    if resource_process and resource_process.metadata_required
                    else False
                )

                if &#34;$&#34; in note_value and meta_value:
                    note_value = note_value.replace(&#34;$&#34;, meta_value)
                elif &#34;$&#34; in note_value and metadata_required and not meta_value:
                    tkmsg.showwarning(
                        message=(
                            f&#34;The process {process.process_var.get()} requires metadata.\n\n&#34;
                            &#34;Please select the correct metadata with the material manager. &#34;
                            &#34;To do so, click the &#39;select&#39; button besides the material input field.&#34;
                        )
                    )
                else:
                    note_value = note_value.replace(&#34;$&#34;, &#34;-&#34;)
                process.note_var.set(note_value)
        else:
            # Remove the widget set if the process has no value
            self.remove(pid)

    def _callback_process(self, pid: int, value: str) -&gt; None:
        &#34;&#34;&#34;
        Callback for the process StringVar trace.

         - Sets the note widget as disabled or normal depending of the value.
         - Sets the state of the following process widgets dependent of the value.

        Args:
            pid (int): The pid from which the trace callback is triggered.
            value (str): The value of the variable.
        &#34;&#34;&#34;
        log.debug(f&#34;Callback trace process: pid={pid}, value={value}&#34;)

        process = self._process_widgets[pid]

        if bool(value):
            process.text_note_process.state = tk.NORMAL
        else:
            process.note_var.set(&#34;&#34;)
            process.text_note_process.state = tk.DISABLED

        if self.exists(pid=pid + 1):
            self.get(pid + 1).state = tk.NORMAL</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.note_vars"><code class="name">var <span class="ident">note_vars</span> : List[tkinter.StringVar]</code></dt>
<dd>
<div class="desc"><p>Returns a list of all StringVar variables for the process notes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def note_vars(self) -&gt; List[StringVar]:
    &#34;&#34;&#34;Returns a list of all StringVar variables for the process notes.&#34;&#34;&#34;
    return [p.note_var for p in self._process_widgets.values()]</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.process_vars"><code class="name">var <span class="ident">process_vars</span> : List[tkinter.StringVar]</code></dt>
<dd>
<div class="desc"><p>Returns a list of all StringVar variables of the process combobox-selections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def process_vars(self) -&gt; List[StringVar]:
    &#34;&#34;&#34;Returns a list of all StringVar variables of the process combobox-selections.&#34;&#34;&#34;
    return [p.process_var for p in self._process_widgets.values()]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, process_value: Optional[str] = None, note_value: Optional[str] = None) ‑> Optional[<a title="pytia_property_manager.app.widgets.processes.ProcessWidget" href="#pytia_property_manager.app.widgets.processes.ProcessWidget">ProcessWidget</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the process combobox and the process note widgets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(
    self, process_value: Optional[str] = None, note_value: Optional[str] = None
) -&gt; Optional[ProcessWidget]:
    &#34;&#34;&#34;Adds the process combobox and the process note widgets.&#34;&#34;&#34;
    new_pid = self._current_pid + 1
    if len(self._process_widgets) &lt;= resource.settings.processes.max - 1:
        widget = ProcessWidget(
            root=self._root,
            pid=new_pid,
            callback_combo=self._callback_combo,
            callback_process=self._callback_process,
        )
        widget.bottom_space = True
        if new_pid &gt; resource.settings.processes.first:
            prev = self.get(pid=new_pid - 1)
            prev.bottom_space = False
            # Only allow the selection of the process if the previous
            # process has been selected. This way we don&#39;t have to sort
            # processes later, because there are no &#39;blank&#39; processes.
            if prev.process_var.get():
                widget.state = tk.NORMAL
            else:
                widget.state = tk.DISABLED

        # self._process_widgets.append(w)
        self._process_widgets[new_pid] = widget
        self._current_pid = new_pid

        if process_value:
            widget.process_var.set(process_value)
        if process_value and note_value:
            widget.note_var.set(note_value)

        log.debug(f&#34;Added new process {new_pid}&#34;)
        return widget
    return None</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, pid: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the content of the widgets with the given pid (process id).
Clears all processes if no pid is provided.</p>
<p>Args:
pid (Optional[int], optional): The process id, which widgets have
to be cleared. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, pid: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Clears the content of the widgets with the given pid (process id).
    Clears all processes if no pid is provided.

    Args:
    pid (Optional[int], optional): The process id, which widgets have \
        to be cleared. Defaults to None.
    &#34;&#34;&#34;
    if pid:
        process = self.get(pid)
        process.process_var.set(&#34;&#34;)
        process.note_var.set(&#34;&#34;)
    else:
        for widget in self._process_widgets.values():
            widget.process_var.set(&#34;&#34;)
            widget.note_var.set(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, pid: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns wether a pid exists or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>The pid to look for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, if the process exists, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, pid: int) -&gt; bool:
    &#34;&#34;&#34;
    Returns wether a pid exists or not.

    Args:
        pid (int): The pid to look for.

    Returns:
        bool: True, if the process exists, False otherwise.
    &#34;&#34;&#34;
    # return True if len(self._process_widgets) &gt; pid else False
    return bool(pid in self._process_widgets)</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, pid: int) ‑> <a title="pytia_property_manager.app.widgets.processes.ProcessWidget" href="#pytia_property_manager.app.widgets.processes.ProcessWidget">ProcessWidget</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a process widget by its pid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>The pid of the desired ProcessWidget.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget" href="#pytia_property_manager.app.widgets.processes.ProcessWidget">ProcessWidget</a></code></dt>
<dd>The desired ProcessWidget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, pid: int) -&gt; ProcessWidget:
    &#34;&#34;&#34;
    Returns a process widget by its pid.

    Args:
        pid (int): The pid of the desired ProcessWidget.

    Returns:
        ProcessWidget: The desired ProcessWidget.
    &#34;&#34;&#34;
    return self._process_widgets[pid]</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, pid: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the process combobox and the process note from the frame.
All widgets (all processes) are going to be deleted, and re-added,
except the one with the given pid (process-id). This ensures that
the tkinter grid will always work.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the process which will be deleted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, pid: int) -&gt; None:
    &#34;&#34;&#34;
    Removes the process combobox and the process note from the frame.
    All widgets (all processes) are going to be deleted, and re-added,
    except the one with the given pid (process-id). This ensures that
    the tkinter grid will always work.

    Args:
        pid (int): The id of the process which will be deleted.
    &#34;&#34;&#34;
    process_store: List[str] = []
    note_store: List[str] = []

    # First: Destroy all widgets from the all processes.
    # Store all processes temporarily.
    for i, widget in enumerate(self._process_widgets.values()):
        process_store.append(widget.process_var.get())
        note_store.append(widget.note_var.get())

        widget.lbl_process.grid_forget()
        widget.combo_process.grid_forget()
        widget.text_note_process.grid_forget()

        widget.lbl_process.destroy()
        widget.combo_process.destroy()
        widget.text_note_process.destroy()
        widget.parent.grid_rowconfigure(i * 2 + 1, weight=0)

    # Remove the process which shall be removed from
    # the list from the temporary store.
    process_store.pop(pid - resource.settings.processes.first)
    note_store.pop(pid - resource.settings.processes.first)

    # Clear the process list that holds all widgets.
    self._process_widgets.clear()

    # Reset the pid counter
    self._current_pid = resource.settings.processes.first - 1

    # Add all widgets from the process store.
    # Remember: The process from the given pid isn&#39;t in the temp
    # store anymore.
    for i, _ in enumerate(process_store):
        self.add(process_value=process_store[i], note_value=note_store[i])

    # Add all processes from the init_amount, if the amount
    # of remaining processes is less than the init amount.
    for i in range(len(process_store), self._init_amount):
        self.add()

    # Add another widget set, if the current one has a value.
    if process_store[-1]:
        self.add()

    log.debug(f&#34;Removed process {pid}&#34;)</code></pre>
</details>
</dd>
<dt id="pytia_property_manager.app.widgets.processes.ProcessWidgets.state"><code class="name flex">
<span>def <span class="ident">state</span></span>(<span>self, state: Literal['normal', 'disabled'], pid: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the state of process widgets. A process widget is only set to state <code>NORMAL</code> if the
previous widget has a value. The state of the process note widgets is set via the
trace callback of the process widgets StringVar, see method <code>_callback_process</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt>state (Literal[&quot;normal&quot;, &quot;disabled&quot;]): The tkinter-state.</dt>
<dt><strong><code>pid</code></strong> :&ensp;<code>Optional[int]</code>, optional</dt>
<dd>The pid from which to set the process.
If None, all processes will be set to the given state. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state(
    self, state: Literal[&#34;normal&#34;, &#34;disabled&#34;], pid: Optional[int] = None
) -&gt; None:
    &#34;&#34;&#34;
    Sets the state of process widgets. A process widget is only set to state `NORMAL` if the
    previous widget has a value. The state of the process note widgets is set via the
    trace callback of the process widgets StringVar, see method `_callback_process`.

    Args:
        state (Literal[&amp;quot;normal&amp;quot;, &amp;quot;disabled&amp;quot;]): The tkinter-state.
        pid (Optional[int], optional): The pid from which to set the process. \
            If None, all processes will be set to the given state. Defaults to None.
    &#34;&#34;&#34;
    if pid:
        self.get(pid).state = state
    else:
        for _, widget in enumerate(self._process_widgets.values()):
            if (
                state == tk.DISABLED
                or widget.pid == resource.settings.processes.first
                or (
                    widget.pid &gt; resource.settings.processes.first
                    and self._process_widgets[widget.pid - 1].process_var.get()
                )
            ):
                widget.state = state</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pytia_property_manager.app.widgets" href="index.html">pytia_property_manager.app.widgets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget" href="#pytia_property_manager.app.widgets.processes.ProcessWidget">ProcessWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.MARGIN_X" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.MARGIN_X">MARGIN_X</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.MARGIN_Y" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.MARGIN_Y">MARGIN_Y</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.bottom_space" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.bottom_space">bottom_space</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.note_var" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.note_var">note_var</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.parent" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.parent">parent</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.pid" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.pid">pid</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.process_var" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.process_var">process_var</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidget.state" href="#pytia_property_manager.app.widgets.processes.ProcessWidget.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets">ProcessWidgets</a></code></h4>
<ul class="two-column">
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.add" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.add">add</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.clear" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.clear">clear</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.exists" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.exists">exists</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.get" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.get">get</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.note_vars" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.note_vars">note_vars</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.process_vars" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.process_vars">process_vars</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.remove" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.remove">remove</a></code></li>
<li><code><a title="pytia_property_manager.app.widgets.processes.ProcessWidgets.state" href="#pytia_property_manager.app.widgets.processes.ProcessWidgets.state">state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>